---
id: T-implement-auto-commit-after
title: Implement auto-commit after message processing
status: open
priority: medium
parent: F-git-version-control
prerequisites:
  - T-implement-gitservice-core
  - T-add-git-settings-protected
affectedFiles: {}
log: []
schema: v1.0
childrenIds: []
created: 2026-02-06T00:42:47.043Z
updated: 2026-02-06T00:42:47.043Z
---

## Context

This task implements automatic git commits after the agent finishes processing a message. After the LLM tool loop completes and the response is recorded, the plugin checks for changes and creates a semantically meaningful commit. The commit message is generated by a lightweight LLM call that receives the context of what happened.

Parent feature: F-git-version-control
Full requirements: `.trellis/requirements/git-version-control.md`
Implementation plan: See F-git-version-control body for full plan.

## Key Files to Modify
- `src/processor/MessageProcessor.ts` — Add auto-commit private methods and hook into post-processing flow (add after line 487, after retrospection handling)
- `src/git/GitService.ts` — May need to add `getChangedFiles()` method if not already present from Task 1

## Key Files to Create
- `tests/processor/autoCommit.test.ts` — Unit tests for auto-commit logic

## Key Files to Reference (read-only — CRITICAL for following existing patterns)
- `src/retrospection/RetrospectionService.ts` — **PRIMARY PATTERN** for lightweight LLM call: create a fresh `new LLMService(app, settings)`, call `initialize()`, call `processMessage(prompt)` with no tools registered
- `src/processor/MessageProcessor.ts` lines 456 and 483 — **PATTERN** for fire-and-forget async calls: `void this.runRetrospection(conv).catch((err) => console.error(...))`
- `src/llm/AnthropicProvider.ts` — Constructor takes `ClaudeModelId`
- `src/types.ts` — Haiku model ID: `"claude-haiku-4-5-20251001"`
- `src/llm/LLMService.ts` — `LLMService(app, settings)` constructor, `processMessage()` returns `LLMResponse`
- `src/llm/types.ts` — `extractTextContent(response)` utility
- `src/git/types.ts` — `GitCommitMetadata`, `GitCommitOptions` types

## Implementation Requirements

### 1. Add `autoCommit` private method to MessageProcessor

```typescript
/**
 * Auto-commit vault changes after successful message processing.
 * Non-critical — failures are logged but never propagate.
 */
private async autoCommit(
  messageText: string,
  toolsUsed: string[],
  conversationId: string
): Promise<void> {
  const gitService = this.plugin.getGitService();
  if (!gitService) return;
  if (!this.settings.autoCommitAfterProcessing) return;

  // Check for changes
  const hasChanges = await gitService.hasChanges();
  if (!hasChanges) return;

  // Get list of changed files from git status
  const changedFiles = await gitService.getChangedFiles();

  // Generate commit message via lightweight Haiku LLM call
  const commitMessage = await this.generateCommitMessage(messageText, toolsUsed, changedFiles);

  // Build metadata
  const metadata: GitCommitMetadata = {
    conversationId,
    toolsUsed,
    filesAffected: changedFiles,
    source: "agent", // MVP: default to "agent", refine later
  };

  // Commit
  await gitService.commitAll({
    type: commitMessage.type,
    summary: commitMessage.summary,
    body: commitMessage.body,
    metadata,
    authorName: this.settings.clientName,
  });
}
```

### 2. Add `generateCommitMessage` private method

**CRITICAL DESIGN DECISION**: Do NOT reuse the message processing LLMService instance. Create a new, minimal one with Haiku. This avoids adding unnecessary conversation history tokens.

```typescript
private async generateCommitMessage(
  originalRequest: string,
  toolsUsed: string[],
  changedFiles: string[]
): Promise<{ type: "vault" | "organize" | "cleanup"; summary: string; body: string }> {
  // Create settings override to force Haiku model
  const commitSettings: SmartHoleSettings = {
    ...this.settings,
    model: "claude-haiku-4-5-20251001" as ClaudeModelId,
  };

  const llmService = new LLMService(this.app, commitSettings);
  await llmService.initialize();

  const prompt = `Generate a concise git commit message for the following changes.
Return ONLY the type line and body. Do not include metadata.

Format:
type(scope): summary

body description

Where type is one of: vault (file changes), organize (moves/renames/folders), cleanup (deletions).

Files changed: ${changedFiles.join(", ")}
User's request: ${originalRequest}
Tools used by agent: ${toolsUsed.join(", ")}`;

  const response = await llmService.processMessage(prompt);
  const text = extractTextContent(response).trim();

  // Parse: first line is "type(scope): summary", rest is body
  const lines = text.split("\n");
  const firstLine = lines[0] || "vault: update files";
  const body = lines.slice(1).join("\n").trim();

  // Extract type from first line
  const typeMatch = firstLine.match(/^(vault|organize|cleanup)/);
  const type = (typeMatch?.[1] as "vault" | "organize" | "cleanup") || "vault";

  return { type, summary: firstLine, body };
}
```

**Import needed** at top of MessageProcessor:
```typescript
import type { ClaudeModelId } from "../types";
import type { GitCommitMetadata } from "../git";
```

### 3. Hook into `processWithRetry()` post-processing

Add AFTER the retrospection handling (after the `isWaitingForResponse` check around line 504), BEFORE the `return { success: true, ... }` at line 506:

```typescript
// Auto-commit after successful processing (fire-and-forget, non-critical)
const activeConversationForCommit = this.conversationManager.getActiveConversation();
if (activeConversationForCommit) {
  void this.autoCommit(
    messageText,
    toolsUsed,
    activeConversationForCommit.id
  ).catch((err) =>
    console.error("MessageProcessor: Auto-commit failed:", err)
  );
}
```

**CRITICAL**: Use `void ... .catch()` pattern (fire-and-forget). Auto-commit failures must NEVER fail message processing. This matches the retrospection pattern at lines 456 and 483.

### 4. Add `getChangedFiles()` to GitService (if not already present)

If T-implement-gitservice-core didn't include this method, add it to `src/git/GitService.ts`:

```typescript
/**
 * Get list of file paths with uncommitted changes.
 */
async getChangedFiles(): Promise<string[]> {
  const matrix = await git.statusMatrix({ fs, dir: this.basePath });
  return matrix
    .filter(([, head, workdir, stage]) => !(head === 1 && workdir === 1 && stage === 1))
    .map(([filepath]) => filepath);
}
```

### 5. Unit Tests (`tests/processor/autoCommit.test.ts`)

Mock GitService, LLMService, and settings. Test the auto-commit behavior in isolation.

**Test sections:**
- **Triggers correctly**: After processing with changes, `gitService.commitAll` is called
- **Skip when no changes**: `hasChanges()` returns false → no commit
- **Skip when disabled**: `autoCommitAfterProcessing` is false → no commit
- **Skip when git disabled**: `getGitService()` returns null → no commit
- **Error handling**: Commit failure doesn't propagate (wrapping catch works)
- **Commit message format**: Metadata block correctly appended to LLM-generated content
- **Haiku model forced**: LLMService created with Haiku model regardless of user setting

## Commit Author

- Author name: `this.settings.clientName` (e.g., "obsidian")
- Author email: `smarthole@local` (hardcoded)

## Risks & Mitigations

- **Double LLM call cost**: Haiku is extremely cheap ($0.001-0.002/call). Negligible.
- **Race conditions**: If two messages process concurrently, they could race on git commit. Mitigate by considering a simple lock in GitService.commitAll (or accept the race for MVP — concurrent processing is rare).
- **Error isolation**: The `void ... .catch()` pattern ensures failures are logged but never propagate.
- **LLM failure for commit message**: If Haiku call fails, the catch block logs and skips the commit. No user-visible impact.

## Acceptance Criteria

- [ ] After successful message processing, auto-commit triggers when git enabled and auto-commit on
- [ ] Auto-commit skips silently when there are no changes
- [ ] Auto-commit skips when disabled in settings
- [ ] Auto-commit skips when git is not enabled
- [ ] Commit messages have LLM-generated summary and body
- [ ] Commit messages include automatically-appended metadata block (conversation, tools, files, source)
- [ ] Commit author uses plugin client name and `smarthole@local` email
- [ ] Lightweight LLM call uses Haiku model regardless of user's model setting
- [ ] Auto-commit failures are logged but don't fail message processing
- [ ] Unit tests cover trigger conditions, skip conditions, error handling, and message formatting
- [ ] `mise run quality` passes

## Out of Scope

- GitService core implementation (handled by T-implement-gitservice-core)
- Settings UI and plugin lifecycle (handled by T-add-git-settings-protected)
- Git history tools for the agent (handled by T-implement-git-history-tools)
- Detecting "mixed" source with full accuracy (acceptable to default to "agent" for MVP)
- Remote push/pull
